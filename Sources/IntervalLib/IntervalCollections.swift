import Foundation

public class IntervalCollection<
    IntervalType: IntervalProtocol>: IntervalCollectionProtocol {
  public typealias Element = IntervalType

  private var _intervals: [IntervalType]

  public init<CompatibleCollection: IntervalCollectionProtocol>(
      _ intervals: CompatibleCollection)
      where CompatibleCollection.Element == Element {
    self._intervals = Array(intervals)
  }
}

extension IntervalCollection: RandomAccessCollection {
  public typealias Index = Int
  public typealias Iterator = Array<Element>.Iterator

  public var startIndex: Index {
    return _intervals.startIndex
  }
  public var endIndex: Index {
    return _intervals.endIndex
  }

  public subscript(index: Index) -> Element {
    return _intervals[index]
  }

  public func index(after i: Index) -> Index {
    return _intervals.index(after: i)
  }

  public func makeIterator() -> Iterator {
    return _intervals.makeIterator()
  }
}

public class IndexedIntervalCollection:
    IntervalCollection<IndexedIntervalCollection.IndexedInterval> {

  public override init<InputCollection: IntervalCollectionProtocol>(
      _ intervals: InputCollection) {
    let converted = intervals.enumerated().map {
        (index: Int, interval: IntervalProtocol) -> IndexedInterval in
      IndexedInterval(interval, index: index)
    }
    super.init(converted)
  }

  public class IndexedInterval: Interval {
    public let index: Int

    public init(_ interval: IntervalProtocol, index: Int) {
      self.index = index
      super.init(interval)
    }

    public func indexedPointAtPosition(_ position: k) -> IndexedPoint {
      return IndexedPoint(interval: self, position: position)
    }

    public func indexedPoint(offset: k) -> IndexedPoint {
      return IndexedPoint(
          interval: self, position: leftBoundary + offset)
    }

    public func intersection(_ i: Interval) -> Subinterval? {
      let left = leftBoundary > i.leftBoundary ? leftBoundary : i.leftBoundary
      let right =
          rightBoundary < i.rightBoundary ? rightBoundary : i.rightBoundary
      if left >= right {
        return nil
      }
      return Subinterval(
          leftBoundary: left, rightBoundary: right, containedIn: self)
    }

    public override var description: String {
      return "IndexedInterval(\(super.shortDescription), index: \(index))"
    }

    public var shortDescription: String {
      return "\(index):\(super.shortDescription)"
    }
  }
  // A subinterval contained in a specified IndexedInterval in this
  // collection.
  public class Subinterval: Interval {
    // The interval this one is contained in in the current IntervalRange.
    public let containingInterval: IndexedInterval

    fileprivate init(
        leftBoundary: k, rightBoundary: k,
        containedIn containingInterval: IndexedInterval) {
      self.containingInterval = containingInterval
      super.init(leftBoundary: leftBoundary, rightBoundary: rightBoundary)
    }

    public override var description: String {
      return "Subinterval(leftBoundary: \(leftBoundary), " +
          "rightBoundary: \(rightBoundary), length: \(length), " + "containingInterval: \(containingInterval)"
    }

  }
  public class IndexedPoint {
    // The interval this point was generated by.
    public let interval: IndexedInterval
    public let position: k

    fileprivate init(
        interval: IndexedInterval, position: k) {
      self.interval = interval
      self.position = position
    }

    public var offset: k {
      return position - interval.leftBoundary
    }
  }
}

// A disjoint nonempty collection of intervals, sorted by position.
// Used as input / output domains for translation maps.
public class IntervalRange: IndexedIntervalCollection {

  public init<InputCollection: IntervalCollectionProtocol>(
      fromSortedIntervals intervals: InputCollection) {
    super.init(intervals)
  }

  public convenience init(fromInterval interval: Interval) {
    self.init(fromSortedIntervals: [interval])
  }

  public convenience init(fromLengths lengths: [k], leftBoundary: k) {
    var pos = leftBoundary
    var intervals: [Interval] = []
    for length in lengths {
      let interval = Interval(leftBoundary: pos, length: length)
      intervals.append(interval)
      pos = interval.rightBoundary
    }
    self.init(fromSortedIntervals: intervals)
  }

  // Assorted helpers
  public var bounds: Interval {
    return Interval(
        leftBoundary: self.first!.leftBoundary,
        rightBoundary: self.last!.rightBoundary)
  }

  public func leftBoundaries() -> [k] {
    return self.map { $0.leftBoundary }
  }

  public func rightBoundaries() -> [k] {
    return self.map { $0.rightBoundary }
  }

  public func lengths() -> [k] {
    return self.map { $0.length }
  }

  public func totalLength() -> k {
    return lengths().reduce(k.zero(), +)
  }

  public func indexedPointAtPosition(_ position: k) -> IndexedPoint? {
    for interval in self {
      if interval.containsPosition(position) {
        return interval.indexedPointAtPosition(position)
      }
    }
    return nil
  }

  public func asSubrangeOf(
      _ refiningIntervals: IntervalRange) -> Subrange? {
    var results: [Subinterval] = []
    var intervalIter = makeIterator()
    var refiningIntervalIter = refiningIntervals.makeIterator()
    var curInterval = intervalIter.next()
    var refiningInterval = refiningIntervalIter.next()
    while curInterval != nil && refiningInterval != nil {
      if curInterval!.rightBoundary <= refiningInterval!.leftBoundary {
        curInterval = intervalIter.next()
      } else {
        if let intersection = refiningInterval!.intersection(curInterval!) {
          results.append(intersection)
        }
        refiningInterval = refiningIntervalIter.next()
      }
    }
    if !results.isEmpty {
      return Subrange(sortedIntervals: results, containedIn: self)
    }
    return nil
  }

  public class ContainmentMap: IntervalMapProtocol {
    public typealias FromType = IntervalRange
    public typealias ToType = IntervalRange
    public typealias IndexMapType = IndexMap<Int, Int>
    public typealias InverseType = ContainmentMap

    public let fromIntervals: IntervalRange
    public let toIntervals: IntervalRange
    public let indexMap: IndexMap<Int, Int>

    fileprivate init(fromIntervals: IntervalRange, toIntervals: IntervalRange,
        indexMap: IndexMap<Int, Int>) {
      self.fromIntervals = fromIntervals
      self.toIntervals = toIntervals
      self.indexMap = indexMap
    }
  }

  public class Intersection: IntervalRange {
    /// Invariant: containmentMaps[*].fromIntervals == self
    public var containmentMaps: [ContainmentMap]

    fileprivate init(containmentMaps: [ContainmentMap]) {
      self.containmentMaps = containmentMaps
      super.init(fromSortedIntervals: containmentMaps.first!.fromIntervals)
    }

    public func containmentMapInto(_ range: IntervalRange) -> ContainmentMap? {
      return containmentMaps.first(where: { $0.toIntervals === range })
    }
  }

  public func intersectionWith(
      _ range: IntervalRange) -> Intersection? {
    var selfIter = makeIterator()
    var rangeIter = range.makeIterator()
    var selfInterval = selfIter.next()
    var rangeInterval = rangeIter.next()
    var newIntervals: [Interval] = []

    // TODO: Add the forward maps for the containments in the two intersected
    // sets.
    while selfInterval != nil && rangeInterval != nil {
      if selfInterval!.rightBoundary <= rangeInterval!.leftBoundary {
        // selfInterval overlaps none of rangeInterval, discard it
        selfInterval = selfIter.next()
      } else if selfInterval!.leftBoundary >= rangeInterval!.rightBoundary {
        rangeInterval = rangeIter.next()
      } else {
        let leftBoundary = Swift.max(
            selfInterval!.leftBoundary, rangeInterval!.leftBoundary)
        let rightBoundary = Swift.min(
            selfInterval!.rightBoundary, rangeInterval!.rightBoundary)
        newIntervals.append(Interval(
            leftBoundary: leftBoundary, rightBoundary: rightBoundary))
        if rightBoundary == selfInterval!.rightBoundary {
          selfInterval = selfIter.next()
        }
        if rightBoundary == rangeInterval!.rightBoundary {
          rangeInterval = rangeIter.next()
        }
      }
    }
    if !newIntervals.isEmpty {
      //return Inclusion(fromIntervals)
      //return Subrange(sortedIntervals: results, containedIn: self)
    }
    return nil

  }

  public class Subrange: IntervalCollection<Subinterval> {
    public let containingRange: IntervalRange

    fileprivate init(
        sortedIntervals: [Subinterval],
        containedIn containingRange: IntervalRange) {
      self.containingRange = containingRange
      super.init(sortedIntervals)
    }

    // TODO: ...not sure if this is really needed?
    private class IntervalInclusion {
      var index: Int
      var length: Int
      init(index: Int, length: Int) {
        self.index = index
        self.length = length
      }
    }
  }
}
