import Foundation

public class IntervalCollection<
    IntervalType: IntervalProtocol>: IntervalCollectionProtocol {
  public typealias Element = IntervalType

  private var _intervals: [IntervalType]

  public init<CompatibleCollection: IntervalCollectionProtocol>(
      _ intervals: CompatibleCollection)
      where CompatibleCollection.Element == Element {
    self._intervals = Array(intervals)
  }

  public init(_ intervalCollection: IntervalCollection) {
    self._intervals = intervalCollection._intervals
  }
}

extension IntervalCollection: RandomAccessCollection {
  public typealias Index = Int
  public typealias Iterator = Array<Element>.Iterator

  public var startIndex: Index {
    return _intervals.startIndex
  }
  public var endIndex: Index {
    return _intervals.endIndex
  }

  public subscript(index: Index) -> Element {
    return _intervals[index]
  }

  public func index(after i: Index) -> Index {
    return _intervals.index(after: i)
  }

  public func makeIterator() -> Iterator {
    return _intervals.makeIterator()
  }
}

public class IndexedIntervalCollection:
    IntervalCollection<IndexedIntervalCollection.IndexedInterval> {

  public override init<InputCollection: IntervalCollectionProtocol>(
      _ intervals: InputCollection) {
    let converted = intervals.enumerated().map {
        (index: Int, interval: IntervalProtocol) -> IndexedInterval in
      IndexedInterval(interval, index: index)
    }
    super.init(converted)
  }

  public init(_ iic: IndexedIntervalCollection) {
    super.init(iic)
  }

  public class IndexedInterval: Interval {
    public let index: Int

    public init(_ interval: IntervalProtocol, index: Int) {
      self.index = index
      super.init(interval)
    }

    public func indexedPointAtPosition(_ position: k) -> IndexedPoint {
      return IndexedPoint(interval: self, position: position)
    }

    public func indexedPoint(offset: k) -> IndexedPoint {
      return IndexedPoint(
          interval: self, position: leftBoundary + offset)
    }

    public override var description: String {
      return "IndexedInterval(\(super.shortDescription), index: \(index))"
    }

    public var shortDescription: String {
      return "\(index):\(super.shortDescription)"
    }
  }
  public class IndexedPoint {
    // The interval this point was generated by.
    public let interval: IndexedInterval
    public let position: k

    fileprivate init(
        interval: IndexedInterval, position: k) {
      self.interval = interval
      self.position = position
    }

    public var offset: k {
      return position - interval.leftBoundary
    }
  }
}

// A disjoint nonempty collection of intervals, sorted by position.
// Used as input / output domains for translation maps.
public class IntervalDomain: IndexedIntervalCollection {

  public init<InputCollection: IntervalCollectionProtocol>(
      fromSortedIntervals intervals: InputCollection) {
    super.init(intervals)
  }

  public init(_ domain: IntervalDomain) {
    super.init(domain)
  }

  public convenience init(fromInterval interval: Interval) {
    self.init(fromSortedIntervals: [interval])
  }

  public convenience init(fromLengths lengths: [k], leftBoundary: k) {
    var pos = leftBoundary
    var intervals: [Interval] = []
    for length in lengths {
      let interval = Interval(leftBoundary: pos, length: length)
      intervals.append(interval)
      pos = interval.rightBoundary
    }
    self.init(fromSortedIntervals: intervals)
  }

  // Assorted helpers
  public var bounds: Interval {
    return Interval(
        leftBoundary: self.first!.leftBoundary,
        rightBoundary: self.last!.rightBoundary)
  }

  public func leftBoundaries() -> [k] {
    return self.map { $0.leftBoundary }
  }

  public func rightBoundaries() -> [k] {
    return self.map { $0.rightBoundary }
  }

  public func lengths() -> [k] {
    return self.map { $0.length }
  }

  public func totalLength() -> k {
    return lengths().reduce(k.zero(), +)
  }

  public func indexedPointAtPosition(_ position: k) -> IndexedPoint? {
    for interval in self {
      if interval.containsPosition(position) {
        return interval.indexedPointAtPosition(position)
      }
    }
    return nil
  }

  public class Cover {
    /// The intervals making up the cover.
    public let intervals: IntervalDomain
    public let coveredRanges: [CountableRange<Int>]
    /// A map from the source interval indices to the index of their
    /// covering interval in `intervals`.
    /// Note that because IntervalDomain indices are sorted by interval
    /// position, this map is nondecreasing in its input index.
    public let indexMap: IndexMap<Int, Int>

    fileprivate init(intervals: IntervalDomain,
        coveredRanges: [CountableRange<Int>], indexMap: IndexMap<Int, Int>) {
      self.intervals = intervals
      self.coveredRanges = coveredRanges
      self.indexMap = indexMap
    }

    func indexRangeCoveredBy(coverIndex: Int) -> CountableRange<Int> {
      return coveredRanges[coverIndex]
    }
  }

  public class Intersection: IntervalDomain {
    /// Invariant: covers[*].inputIntervals == self
    public var covers: [Cover]

    fileprivate init(_ intervals: IntervalDomain, covers: [Cover]) {
      self.covers = covers
      super.init(intervals)
    }

    public func coveredBy(
        _ domain: IntervalDomain) -> Cover? {
      return covers.first(where: { $0.intervals === domain })
    }
  }

  public func intersectionWith(_ domain: IntervalDomain) -> Intersection? {
    let domain0 = self
    let domain1 = domain
    var curIndex0 = domain0.startIndex
    var curLength0 = 0
    var curIndex1 = domain1.startIndex
    var curLength1 = 0
    var coverMap0: [Index: Index] = [:]
    var coverMap1: [Index: Index] = [:]
    var coveredRanges0: [CountableRange<Int>] = []
    var coveredRanges1: [CountableRange<Int>] = []

    var newIntervals: [Interval] = []

    while curIndex0 != domain0.endIndex && curIndex1 != domain1.endIndex {
      let interval0 = domain0[curIndex0]
      let interval1 = domain1[curIndex1]
      if interval0.rightBoundary <= interval1.leftBoundary {
        curIndex0 += 1
      } else if interval1.rightBoundary <= interval0.leftBoundary {
        curIndex1 += 1
      } else {
        curLength0 += 1
        curLength1 += 1
        let leftBoundary = Swift.max(
            interval0.leftBoundary, interval1.leftBoundary)
        let rightBoundary = Swift.min(
            interval0.rightBoundary, interval1.rightBoundary)
        let newIndex = newIntervals.count
        coverMap0[newIndex] = curIndex0
        coverMap1[newIndex] = curIndex1
        newIntervals.append(Interval(
            leftBoundary: leftBoundary, rightBoundary: rightBoundary))
        if rightBoundary == interval0.rightBoundary {
          coveredRanges0.append((newIndex - curLength0 + 1)..<(newIndex + 1))
          curIndex0 += 1
          curLength0 = 0
        }
        if rightBoundary == interval1.rightBoundary {
          coveredRanges1.append((newIndex - curLength1 + 1)..<(newIndex + 1))
          curIndex1 += 1
          curLength1 = 0
        }
      }
    }
    let intersection = IntervalDomain(fromSortedIntervals: newIntervals)
    if !newIntervals.isEmpty {
      let cover0 = Cover(
          intervals: domain0, coveredRanges: coveredRanges0,
          indexMap: IndexMap(forwardMap: coverMap0))
      let cover1 = Cover(
          intervals: domain1, coveredRanges: coveredRanges1,
          indexMap: IndexMap(forwardMap: coverMap1))
      return Intersection(
          intersection, covers: [cover0, cover1])
    }
    return nil
  }
}
